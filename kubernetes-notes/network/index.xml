<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HUWEIHUAHG – 容器网络</title>
    <link>https://k8s.huweihuang.com/kubernetes-notes/network/</link>
    <description>Recent content in 容器网络 on HUWEIHUAHG</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://k8s.huweihuang.com/kubernetes-notes/network/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Kubernetes-Notes: Docker网络</title>
      <link>https://k8s.huweihuang.com/kubernetes-notes/network/docker-network/</link>
      <pubDate>Sun, 13 Aug 2017 10:50:57 +0000</pubDate>
      
      <guid>https://k8s.huweihuang.com/kubernetes-notes/network/docker-network/</guid>
      <description>
        
        
        &lt;h1 id=&#34;1-docker的网络基础&#34;&gt;1. Docker的网络基础&lt;/h1&gt;
&lt;h2 id=&#34;1-1-network-namespace&#34;&gt;1.1. Network Namespace&lt;/h2&gt;
&lt;p&gt;不同的网络命名空间中，协议栈是独立的，完全隔离，彼此之间无法通信。同一个网络命名空间有独立的路由表和独立的&lt;code&gt;Iptables/Netfilter&lt;/code&gt;来提供包的转发、NAT、IP包过滤等功能。&lt;/p&gt;
&lt;h3 id=&#34;1-1-1-网络命名空间的实现&#34;&gt;1.1.1. 网络命名空间的实现&lt;/h3&gt;
&lt;p&gt;将与网络协议栈相关的全局变量变成一个&lt;code&gt;Net Namespace&lt;/code&gt;变量的成员，然后在调用协议栈函数中加入一个Namepace参数。&lt;/p&gt;
&lt;h3 id=&#34;1-1-2-网络命名空间的操作&#34;&gt;1.1.2. 网络命名空间的操作&lt;/h3&gt;
&lt;p&gt;1、创建网络命名空间&lt;/p&gt;
&lt;p&gt;ip netns add &lt;code&gt;name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、在命名空间内执行命令&lt;/p&gt;
&lt;p&gt;ip netns exec &lt;code&gt;name&lt;/code&gt; &lt;code&gt;command&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、进入命名空间&lt;/p&gt;
&lt;p&gt;ip netns exec &lt;code&gt;name&lt;/code&gt; bash&lt;/p&gt;
&lt;h1 id=&#34;2-docker的网络实现&#34;&gt;2. Docker的网络实现&lt;/h1&gt;
&lt;h2 id=&#34;2-1-容器网络&#34;&gt;2.1. 容器网络&lt;/h2&gt;
&lt;p&gt;Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。&lt;/p&gt;
&lt;p&gt;Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578957/article/kubernetes/network/container-network.png&#34; alt=&#34;这里写图片描述&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-2-4类网络模式&#34;&gt;2.2. 4类网络模式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Docker网络模式&lt;/th&gt;
&lt;th&gt;配置&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;host模式&lt;/td&gt;
&lt;td&gt;--net=host&lt;/td&gt;
&lt;td&gt;容器和宿主机共享Network namespace。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;container模式&lt;/td&gt;
&lt;td&gt;--net=container:NAME_or_ID&lt;/td&gt;
&lt;td&gt;容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;none模式&lt;/td&gt;
&lt;td&gt;--net=none&lt;/td&gt;
&lt;td&gt;容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bridge模式&lt;/td&gt;
&lt;td&gt;--net=bridge（默认为该模式）&lt;/td&gt;
&lt;td&gt;桥接模式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;3-docker网络模式&#34;&gt;3. Docker网络模式&lt;/h1&gt;
&lt;h2 id=&#34;3-1-bridge桥接模式&#34;&gt;3.1. bridge桥接模式&lt;/h2&gt;
&lt;p&gt;在bridge模式下，Docker可以使用独立的网络栈。实现方式是父进程在创建子进程的时候通过传入&lt;code&gt;CLONE_NEWNET&lt;/code&gt;的参数创建出一个网络命名空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker Daemon首次启动时会创建一个虚拟网桥docker0，地址通常为172.x.x.x开头，在私有的网络空间中给这个网络分配一个子网。&lt;/li&gt;
&lt;li&gt;由Docker创建处理的每个容器，都会创建一个虚拟以太设备对（veth pair），一端关联到网桥，另一端使用Namespace技术映射到容器内的eth0设备，然后从网桥的地址段内给eth0接口分配一个IP地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578957/article/kubernetes/network/bridge.png&#34; alt=&#34;这里写图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;一般情况，宿主机IP与docker0 IP、容器IP是不同的IP段，默认情况，外部看不到docker0和容器IP，对于外部来说相当于docker0和容器的IP为内网IP。&lt;/p&gt;
&lt;h3 id=&#34;3-1-1-外部网络访问docker容器&#34;&gt;3.1.1. 外部网络访问Docker容器&lt;/h3&gt;
&lt;p&gt;外部访问docker容器可以通过&lt;code&gt;端口映射(NAT)&lt;/code&gt;的方式，Docker使用NAT的方式将容器内部的服务与宿主机的某个端口port_1绑定。&lt;/p&gt;
&lt;p&gt;外部访问容器的流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外界网络通过宿主机的IP和映射的端口port_1访问。&lt;/li&gt;
&lt;li&gt;当宿主机收到此类请求，会通过DNAT将请求的目标IP即宿主机IP和目标端口即映射端口port_1替换成容器的IP和容器的端口port_0。&lt;/li&gt;
&lt;li&gt;由于宿主机上可以识别容器IP，所以宿主机将请求发给veth pair。&lt;/li&gt;
&lt;li&gt;veth pair将请求发送给容器内部的eth0，由容器内部的服务进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-1-2-docker容器访问外部网络&#34;&gt;3.1.2. Docker容器访问外部网络&lt;/h3&gt;
&lt;p&gt;docker容器访问外部网络的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;docker容器向外部目标IP和目标端口port_2发起请求，请求报文中的源IP为容器IP。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求通过容器内部的eth0到veth pair的另一端docker0网桥。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker0网桥通过数据报转发功能将请求转发到宿主机的eth0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宿主机处理请求时通过SNAT将请求中的源IP换成宿主机eth0的IP。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理后的报文通过请求的目标IP发送到外部网络。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-1-3-缺点&#34;&gt;3.1.3. 缺点&lt;/h3&gt;
&lt;p&gt;使用NAT的方式可能会带来性能的问题，影响网络传输效率。&lt;/p&gt;
&lt;h2 id=&#34;3-2-host模式&#34;&gt;3.2. host模式&lt;/h2&gt;
&lt;p&gt;host模式并没有给容器创建一个隔离的网络环境，而是和宿主机共用一个网络命名空间，容器使用宿主机的eth0和外界进行通信，同样容器也共用宿主机的端口资源，即分配端口可能存在与宿主机已分配的端口冲突的问题。&lt;/p&gt;
&lt;p&gt;实现的方式即父进程在创建子进程的时候不传入&lt;code&gt;CLONE_NEWNET&lt;/code&gt;的参数，从而和宿主机共享一个网络空间。&lt;/p&gt;
&lt;p&gt;host模式没有通过NAT的方式进行转发因此性能上相对较好，但是不存在网络隔离性，可能产生端口冲突的问题。&lt;/p&gt;
&lt;h2 id=&#34;3-3-container模式&#34;&gt;3.3. container模式&lt;/h2&gt;
&lt;p&gt;container模式即docker容器可以使用其他容器的网络命名空间，即和其他容器处于同一个网络命名空间。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查找其他容器的网络命名空间。&lt;/li&gt;
&lt;li&gt;新创建的容器的网络命名空间使用其他容器的网络命名空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过和其他容器共享网络命名空间的方式，可以让不同的容器之间处于相同的网络命名空间，可以直接通过localhost的方式进行通信，简化了强关联的多个容器之间的通信问题。&lt;/p&gt;
&lt;p&gt;k8s中的pod的概念就是通过一组容器共享一个网络命名空间来达到pod内部的不同容器可以直接通过localhost的方式进行通信。&lt;/p&gt;
&lt;h2 id=&#34;3-4-none模式&#34;&gt;3.4. none模式&lt;/h2&gt;
&lt;p&gt;none模式即不为容器创建任何的网络环境，用户可以根据自己的需要手动去创建不同的网络定制配置。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Docker源码分析》&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Kubernetes-Notes: K8S网络</title>
      <link>https://k8s.huweihuang.com/kubernetes-notes/network/kubernetes-network/</link>
      <pubDate>Sun, 13 Aug 2017 10:50:57 +0000</pubDate>
      
      <guid>https://k8s.huweihuang.com/kubernetes-notes/network/kubernetes-network/</guid>
      <description>
        
        
        &lt;h1 id=&#34;1-kubernetes网络模型&#34;&gt;1. kubernetes网络模型&lt;/h1&gt;
&lt;h2 id=&#34;1-1-基础原则&#34;&gt;1.1. 基础原则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;每个Pod都拥有一个独立的IP地址，而且假定所有Pod都在一个可以直接连通的、扁平的网络空间中，不管是否运行在同一Node上都可以通过Pod的IP来访问。&lt;/li&gt;
&lt;li&gt;k8s中Pod的IP是最小粒度IP。同一个Pod内所有的容器共享一个网络堆栈，该模型称为IP-per-Pod模型。&lt;/li&gt;
&lt;li&gt;Pod由docker0实际分配的IP，Pod内部看到的IP地址和端口与外部保持一致。同一个Pod内的不同容器共享网络，可以通过localhost来访问对方的端口，类似同一个VM内的不同进程。&lt;/li&gt;
&lt;li&gt;IP-per-Pod模型从端口分配、域名解析、服务发现、负载均衡、应用配置等角度看，Pod可以看作是一台独立的VM或物理机。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-2-k8s对集群的网络要求&#34;&gt;1.2. k8s对集群的网络要求&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;所有容器都可以不用NAT的方式同别的容器通信。&lt;/li&gt;
&lt;li&gt;所有节点都可以在不同NAT的方式下同所有容器通信，反之亦然。&lt;/li&gt;
&lt;li&gt;容器的地址和别人看到的地址是同一个地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的集群网络要求可以通过第三方开源方案实现，例如flannel。&lt;/p&gt;
&lt;h2 id=&#34;1-3-网络架构图&#34;&gt;1.3. 网络架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578957/article/kubernetes/network/network-arch.png&#34; alt=&#34;这里写图片描述&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-4-k8s集群ip概念汇总&#34;&gt;1.4. k8s集群IP概念汇总&lt;/h2&gt;
&lt;p&gt;由集群外部到集群内部：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IP类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Proxy-IP&lt;/td&gt;
&lt;td&gt;代理层公网地址IP，外部访问应用的网关服务器。[实际需要关注的IP]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Service-IP&lt;/td&gt;
&lt;td&gt;Service的固定虚拟IP，Service-IP是内部，外部无法寻址到。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Node-IP&lt;/td&gt;
&lt;td&gt;容器宿主机的主机IP。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container-Bridge-IP&lt;/td&gt;
&lt;td&gt;容器网桥（docker0）IP，容器的网络都需要通过容器网桥转发。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pod-IP&lt;/td&gt;
&lt;td&gt;Pod的IP，等效于Pod中网络容器的Container-IP。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container-IP&lt;/td&gt;
&lt;td&gt;容器的IP，容器的网络是个隔离的网络空间。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;2-kubernetes的网络实现&#34;&gt;2. kubernetes的网络实现&lt;/h1&gt;
&lt;p&gt;k8s网络场景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器与容器之间的直接通信。&lt;/li&gt;
&lt;li&gt;Pod与Pod之间的通信。&lt;/li&gt;
&lt;li&gt;Pod到Service之间的通信。&lt;/li&gt;
&lt;li&gt;集群外部与内部组件之间的通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-1-pod网络&#34;&gt;2.1. Pod网络&lt;/h2&gt;
&lt;p&gt;Pod作为kubernetes的最小调度单元，Pod是容器的集合，是一个逻辑概念，Pod包含的容器都运行在同一个宿主机上，这些容器将拥有同样的网络空间，容器之间能够互相通信，它们能够在本地访问其它容器的端口。 实际上Pod都包含一个网络容器，它不做任何事情，只是用来接管Pod的网络，业务容器通过加入网络容器的网络从而实现网络共享。Pod网络本质上还是容器网络，所以Pod-IP就是网络容器的Container-IP。&lt;/p&gt;
&lt;p&gt;一般将容器云平台的网络模型打造成一个扁平化网络平面，在这个网络平面内，Pod作为一个网络单元同Kubernetes Node的网络处于同一层级。&lt;/p&gt;
&lt;h2 id=&#34;2-2-pod内部容器之间的通信&#34;&gt;2.2. Pod内部容器之间的通信&lt;/h2&gt;
&lt;p&gt;同一个Pod之间的不同容器因为共享同一个网络命名空间，所以可以直接通过localhost直接通信。&lt;/p&gt;
&lt;h2 id=&#34;2-3-pod之间的通信&#34;&gt;2.3. Pod之间的通信&lt;/h2&gt;
&lt;h3 id=&#34;2-3-1-同node的pod之间的通信&#34;&gt;2.3.1. 同Node的Pod之间的通信&lt;/h3&gt;
&lt;p&gt;同一个Node内，不同的Pod都有一个全局IP，可以直接通过Pod的IP进行通信。Pod地址和docker0在同一个网段。&lt;/p&gt;
&lt;p&gt;在pause容器启动之前，会创建一个虚拟以太网接口对（veth pair），该接口对一端连着容器内部的eth0 ，一端连着容器外部的vethxxx，vethxxx会绑定到容器运行时配置使用的网桥bridge0上，从该网络的IP段中分配IP给容器的eth0。&lt;/p&gt;
&lt;p&gt;当同节点上的Pod-A发包给Pod-B时，包传送路线如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pod-a的eth0—&amp;gt;pod-a的vethxxx—&amp;gt;bridge0—&amp;gt;pod-b的vethxxx—&amp;gt;pod-b的eth0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为相同节点的bridge0是相通的，因此可以通过bridge0来完成不同pod直接的通信，但是不同节点的bridge0是不通的，因此不同节点的pod之间的通信需要将不同节点的bridge0给连接起来。&lt;/p&gt;
&lt;h3 id=&#34;2-3-2-不同node的pod之间的通信&#34;&gt;2.3.2. 不同Node的Pod之间的通信&lt;/h3&gt;
&lt;p&gt;不同的Node之间，Node的IP相当于外网IP，可以直接访问，而Node内的docker0和Pod的IP则是内网IP，无法直接跨Node访问。需要通过Node的网卡进行转发。&lt;/p&gt;
&lt;p&gt;所以不同Node之间的通信需要达到两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对整个集群中的Pod-IP分配进行规划，不能有冲突（可以通过第三方开源工具来管理，例如flannel）。&lt;/li&gt;
&lt;li&gt;将Node-IP与该Node上的Pod-IP关联起来，通过Node-IP再转发到Pod-IP。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同节点的Pod之间的通信需要将不同节点的bridge0给连接起来。连接不同节点的bridge0的方式有好几种，主要有overlay和underlay，或常规的三层路由。&lt;/p&gt;
&lt;p&gt;不同节点的bridge0需要不同的IP段，保证Pod IP分配不会冲突，节点的物理网卡eth0也要和该节点的网桥bridge0连接。因此，节点a上的pod-a发包给节点b上的pod-b，路线如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;节点a上的pod-a的eth0—&amp;gt;pod-a的vethxxx—&amp;gt;节点a的bridge0—&amp;gt;节点a的eth0—&amp;gt;

节点b的eth0—&amp;gt;节点b的bridge0—&amp;gt;pod-b的vethxxx—&amp;gt;pod-b的eth0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578957/article/kubernetes/network/pod-network.png&#34; alt=&#34;这里写图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Pod间实现通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：Pod1和Pod2（同主机），Pod1和Pod3(跨主机)能够通信&lt;/p&gt;
&lt;p&gt;实现：因为Pod的Pod-IP是Docker网桥分配的，Pod-IP是同Node下全局唯一的。所以将不同Kubernetes Node的 Docker网桥配置成不同的IP网段即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Node与Pod间实现通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：Node1和Pod1/ Pod2(同主机)，Pod3(跨主机)能够通信&lt;/p&gt;
&lt;p&gt;实现：在容器集群中创建一个覆盖网络(Overlay Network)，联通各个节点，目前可以通过第三方网络插件来创建覆盖网络，比如Flannel和Open vSwitch等。&lt;/p&gt;
&lt;p&gt;不同节点间的Pod访问也可以通过calico形成的Pod IP的路由表来解决。&lt;/p&gt;
&lt;h2 id=&#34;2-4-service网络&#34;&gt;2.4. Service网络&lt;/h2&gt;
&lt;p&gt;Service的就是在Pod之间起到服务代理的作用，对外表现为一个单一访问接口，将请求转发给Pod，Service的网络转发是Kubernetes实现服务编排的关键一环。Service都会生成一个虚拟IP，称为Service-IP， Kuberenetes Porxy组件负责实现Service-IP路由和转发，在容器覆盖网络之上又实现了虚拟转发网络。&lt;/p&gt;
&lt;p&gt;Kubernetes Porxy实现了以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;转发访问Service的Service-IP的请求到Endpoints(即Pod-IP)。&lt;/li&gt;
&lt;li&gt;监控Service和Endpoints的变化，实时刷新转发规则。&lt;/li&gt;
&lt;li&gt;负载均衡能力。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-开源的网络组件&#34;&gt;3. 开源的网络组件&lt;/h1&gt;
&lt;h2 id=&#34;3-1-flannel&#34;&gt;3.1. Flannel&lt;/h2&gt;
&lt;p&gt;具体参考&lt;a href=&#34;flannel/flannel-introduction.md&#34;&gt;Flannel介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考《Kubernetes权威指南》&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Kubernetes-Notes: CNI</title>
      <link>https://k8s.huweihuang.com/kubernetes-notes/network/cni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://k8s.huweihuang.com/kubernetes-notes/network/cni/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Kubernetes-Notes: 网络插件</title>
      <link>https://k8s.huweihuang.com/kubernetes-notes/network/flannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://k8s.huweihuang.com/kubernetes-notes/network/flannel/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Kubernetes-Notes: k8s网关</title>
      <link>https://k8s.huweihuang.com/kubernetes-notes/network/gateway/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://k8s.huweihuang.com/kubernetes-notes/network/gateway/</guid>
      <description>
        
        
        
      </description>
    </item>
    
  </channel>
</rss>
